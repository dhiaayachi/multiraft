// Code generated by mockery v2.43.2. DO NOT EDIT.

package transport

import (
	io "io"

	raft "github.com/hashicorp/raft"
	mock "github.com/stretchr/testify/mock"
)

// MockTransportRaft is an autogenerated mock type for the TransportRaft type
type MockTransportRaft struct {
	mock.Mock
}

// AppendEntries provides a mock function with given fields: id, target, args, resp
func (_m *MockTransportRaft) AppendEntries(id raft.ServerID, target raft.ServerAddress, args *raft.AppendEntriesRequest, resp *raft.AppendEntriesResponse) error {
	ret := _m.Called(id, target, args, resp)

	if len(ret) == 0 {
		panic("no return value specified for AppendEntries")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(raft.ServerID, raft.ServerAddress, *raft.AppendEntriesRequest, *raft.AppendEntriesResponse) error); ok {
		r0 = rf(id, target, args, resp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AppendEntriesPipeline provides a mock function with given fields: id, target
func (_m *MockTransportRaft) AppendEntriesPipeline(id raft.ServerID, target raft.ServerAddress) (raft.AppendPipeline, error) {
	ret := _m.Called(id, target)

	if len(ret) == 0 {
		panic("no return value specified for AppendEntriesPipeline")
	}

	var r0 raft.AppendPipeline
	var r1 error
	if rf, ok := ret.Get(0).(func(raft.ServerID, raft.ServerAddress) (raft.AppendPipeline, error)); ok {
		return rf(id, target)
	}
	if rf, ok := ret.Get(0).(func(raft.ServerID, raft.ServerAddress) raft.AppendPipeline); ok {
		r0 = rf(id, target)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(raft.AppendPipeline)
		}
	}

	if rf, ok := ret.Get(1).(func(raft.ServerID, raft.ServerAddress) error); ok {
		r1 = rf(id, target)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Close provides a mock function with given fields:
func (_m *MockTransportRaft) Close() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Close")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Consumer provides a mock function with given fields:
func (_m *MockTransportRaft) Consumer() <-chan raft.RPC {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Consumer")
	}

	var r0 <-chan raft.RPC
	if rf, ok := ret.Get(0).(func() <-chan raft.RPC); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(chan raft.RPC)
		}
	}

	return r0
}

// DecodePeer provides a mock function with given fields: _a0
func (_m *MockTransportRaft) DecodePeer(_a0 []byte) raft.ServerAddress {
	ret := _m.Called(_a0)

	if len(ret) == 0 {
		panic("no return value specified for DecodePeer")
	}

	var r0 raft.ServerAddress
	if rf, ok := ret.Get(0).(func([]byte) raft.ServerAddress); ok {
		r0 = rf(_a0)
	} else {
		r0 = ret.Get(0).(raft.ServerAddress)
	}

	return r0
}

// EncodePeer provides a mock function with given fields: id, addr
func (_m *MockTransportRaft) EncodePeer(id raft.ServerID, addr raft.ServerAddress) []byte {
	ret := _m.Called(id, addr)

	if len(ret) == 0 {
		panic("no return value specified for EncodePeer")
	}

	var r0 []byte
	if rf, ok := ret.Get(0).(func(raft.ServerID, raft.ServerAddress) []byte); ok {
		r0 = rf(id, addr)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	return r0
}

// InstallSnapshot provides a mock function with given fields: id, target, args, resp, data
func (_m *MockTransportRaft) InstallSnapshot(id raft.ServerID, target raft.ServerAddress, args *raft.InstallSnapshotRequest, resp *raft.InstallSnapshotResponse, data io.Reader) error {
	ret := _m.Called(id, target, args, resp, data)

	if len(ret) == 0 {
		panic("no return value specified for InstallSnapshot")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(raft.ServerID, raft.ServerAddress, *raft.InstallSnapshotRequest, *raft.InstallSnapshotResponse, io.Reader) error); ok {
		r0 = rf(id, target, args, resp, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// LocalAddr provides a mock function with given fields:
func (_m *MockTransportRaft) LocalAddr() raft.ServerAddress {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for LocalAddr")
	}

	var r0 raft.ServerAddress
	if rf, ok := ret.Get(0).(func() raft.ServerAddress); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(raft.ServerAddress)
	}

	return r0
}

// RequestPreVote provides a mock function with given fields: id, target, args, resp
func (_m *MockTransportRaft) RequestPreVote(id raft.ServerID, target raft.ServerAddress, args *raft.RequestPreVoteRequest, resp *raft.RequestPreVoteResponse) error {
	ret := _m.Called(id, target, args, resp)

	if len(ret) == 0 {
		panic("no return value specified for RequestPreVote")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(raft.ServerID, raft.ServerAddress, *raft.RequestPreVoteRequest, *raft.RequestPreVoteResponse) error); ok {
		r0 = rf(id, target, args, resp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RequestVote provides a mock function with given fields: id, target, args, resp
func (_m *MockTransportRaft) RequestVote(id raft.ServerID, target raft.ServerAddress, args *raft.RequestVoteRequest, resp *raft.RequestVoteResponse) error {
	ret := _m.Called(id, target, args, resp)

	if len(ret) == 0 {
		panic("no return value specified for RequestVote")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(raft.ServerID, raft.ServerAddress, *raft.RequestVoteRequest, *raft.RequestVoteResponse) error); ok {
		r0 = rf(id, target, args, resp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetHeartbeatHandler provides a mock function with given fields: cb
func (_m *MockTransportRaft) SetHeartbeatHandler(cb func(raft.RPC)) {
	_m.Called(cb)
}

// TimeoutNow provides a mock function with given fields: id, target, args, resp
func (_m *MockTransportRaft) TimeoutNow(id raft.ServerID, target raft.ServerAddress, args *raft.TimeoutNowRequest, resp *raft.TimeoutNowResponse) error {
	ret := _m.Called(id, target, args, resp)

	if len(ret) == 0 {
		panic("no return value specified for TimeoutNow")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(raft.ServerID, raft.ServerAddress, *raft.TimeoutNowRequest, *raft.TimeoutNowResponse) error); ok {
		r0 = rf(id, target, args, resp)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewMockTransportRaft creates a new instance of MockTransportRaft. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTransportRaft(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTransportRaft {
	mock := &MockTransportRaft{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
